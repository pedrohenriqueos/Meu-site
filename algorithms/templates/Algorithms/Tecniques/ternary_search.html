{% extends 'base.html' %}

{% block conteudo %}
<article class="mb-4">
    <div class="container px-4 px-lg-5">
        <div class="row gx-4 gx-lg-5 justify-content-center">
            <div class="col-md-10 col-lg-8 col-xl-7">
                <center><h2>Busca Ternária</h2></center>
                <p>Busca ternária trata-se de uma busca em uma equação do segundo grau. Então os valores se comportam na seguinte forma:</p>
                <p>Array[] = {50, 25, 23, 15, 7, 10, 16}</p>
                <p>Array[] = {18, 26, 34, 36, 32, 31, 26}</p>
                <p>Tendo isso em mente, o array possui três pontos importantes, os pontos da equação e o ponto ótimo da equação. 
                    Logo é necessário ter o intervalo armazenado, como left e right, para a busca ternária não existe apenas um meio e sim dois, 
                    pois como o se trata de um intervalo [left, ponto ótimo, right], esse intervalo tem que se manter verdadeiro durante toda a busca. 
                    Então será descido um dos pontos para se aproximar da resposta, gerando o próximo passo: [novo left, ponto ótimo, right] ou [left, ponto ótimo,novo right], 
                    dependendo de qual ponto continua respeitando a relação [left,ponto ótimo,right]. Gerando o código:
                </p>
                <pre>
                    <code>
int n = 7;
Array[] = {50 , 25, 23, 15, 7, 10, 16}
int ternary_search(){
    int left = 0,right = n-1;
    while(right > left){
        int m1 = left + (right - left) / 3;
        int m2 = right - (right - left) / 3;
        if(Array[m1] < Array[m2]) // < minimum, > maximum
            right = m2 - 1;
        else 
            left = m1 + 1;
    }
    return Array[left];
}
                    </code>
                </pre>
                <p>A busca ternária é normalmente usada para achar os pontos máximo ou mínimo.
                    Assim para achar valores mínimos ou máximos em ponto flutuante, temos o seguinte código:</p>
                <pre>
                    <code>
double l = 0.0,r = 1e7; //search limit
for(int it = 0;it < 100; it++){
    double m1 = l+(r-l)/3.0;
    double m2 = r-(r-l)/3.0;
    if(func(m1) < func(m2)) //< minimum, > maximum
        r = m2;
    else 
        l = m1;
}
                    </code>
                </pre>
                <p>Como trata-se de uma busca ternária, a complexidade é O(log(N)) com 100 interações a precisão é muito alta.</p>
                <p>A função 'func' é uma modularização para aplicar o algoritmo dependendo da aplicação, determinando a função através da função.</p>
                <p>Ainda existe uma outra forma de aplicar se os dados da busca ternária todos forem inteiros, pode-se fazer busca binária na derivada da função. Tendo o código:</p>
                <pre>
                    <code>
int l=0,r=1e7;//search limit
while(r-l>1){
    int m = (l+r)/2;
    if(f(m) < f(m+1)) // < minimum, > maximum
        r=m;
    else l=m;
}
                    </code>
                </pre>
            </div>
        </div>
    </div>
</article>

{% endblock %}